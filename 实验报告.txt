光线追踪算法实现：


实现环境：
	macOS Sierra，Xcode工程编辑代码,g++编译，终端运行
	使用opengl库中的基础函数（画线，创建窗口相关）

实现代码：
	见工程下main.cpp：
	主实现代码
	实现了场景里有球，长方体（四面体均可），平面 搭配下的光线追踪，

实现结果：
	见result
	分别是
	1.单光源，4球
	2.双光源，4球
	3.双光源，3球1立方体
	4.单光源，2球2立方体
	5.改变视角，2球2立方体
	6.将视角退后些，缓解某些球位于边界的视角扭曲问题
	7.修正单位化bug之后的改变视角，2球2立方体2光源
	8.转换视角，优化立方体求交算法，3球2立方体3光源


主要的类：
***********************************************************
vec:三维向量，实现了相应的向量加法，点乘，叉积，向量比较等方法
X,y,z:向量的三维坐标
len:向量的长度
slen:向量的长度的平方
***********************************************************
color:即 vec

其中的两个常量:

Ienvironment：环境光，RGB配色，默认(10,10,10)

ZERO:零向量（0，0，0）
***********************************************************
Ray:光线，st表示发出点，dir表示方向，dir为单位化的向量
***********************************************************
shape:环境中放置的物体的父类，内部有虚函数以便于实现多态
包含与物体材质相关的四个系数，以及与折射相关的一个系数n
kA：环境光反射系数（三维分别对应红绿蓝，下同）
kD：漫反射系数
kS：镜面反射系数
kT：折射系数
n:该物体的折射率
***********************************************************
circle:球（其实才反应过来应该是sphere），继承shape
多出来的两个参数
center:三维坐标，球心坐标
dim:半径
***********************************************************
plane:平面，继承shape
多出来的两个参数
n:平面的法向量
dis:平面上任意一点到原点的向量和平面法向量的点积
(所有点和法向量的点积是一样的)

***********************************************************
rectangle:长方形（实际上四边形即可）
a,b,c,d:逆时针或者顺时针排序的四个顶点的坐标
n:法向量
dis:该长方形所在平面的dis（同Plane里dis含义）

***********************************************************
cuboid:立方体，继承shape
r[6]:立方体的6个面，类型是rectangle

***********************************************************
camera:摄像机，即观察者视角，用于设定光线追踪的初始处

eye:摄像机的位置，三维坐标,vec
forward:摄像机的正前方的向量，单位化，vec
right:摄像机的正右方的向量，单位化，vec
up:摄像机的正上方的向量，单位化，vec
stdUp:用于最初的粗略判断哪边是上方(right和up是求出来的）
fov:摄像机的观察角度的大小（默认左右视野角和上下视野角相同）
scale:摄像机观察距离它1单位的平面的视野的宽度或者高度
***********************************************************
light:灯，光源，这里默认的是向四面八方发射光的点光源

pos:光源位置
color:光源发射的光的颜色，默认(255,255,255)(白光）
***********************************************************


实现过程：

分别实现以上类，然后将所有的物体建立对应的类，插入到函数接口所需要的
shapeLst(物体列表）
lightLst(光源列表）里
然后利用shape类里的四个公共虚函数编写主函数 RayTracing（光线追踪）

由于折射部分比较简单与物体无关，因此单独抽出来写出单独的函数refraction
差不多就是这样的过程。

困难的是调试，大概犯过的错误
1）一开始在圆的求交忘记把R*R加入方程中
2）在图像边界处的图形扭曲问题，一开始以为是自己的实现错误，询问室友发现
只要把摄像机摆远一点就好了，单点透视似乎会引起这样的变形
3）阴影的判定函数，把判定返回布尔值弄反了，导致最后该阴影的部分全亮，不该
阴影的部分全黑。
4）一些内部运算的错误
5）和光线有关的参数的理解问题，最初根本不知道哪些参数对应能调出哪些材质和颜色，
反复试验几次之后才渐渐有感觉。
6) 最后还出现了图片部分区域出现奇怪亮斑的错误，最后通过debug检查发现是单位化的时候
没有特判0的情况，如果是0向量就不能单位化，否则后面计算都是NAN，就会对原图造成破坏


实现心得：

1）光线追踪主要需要实现的还是在各种形状的表面和内部的光线折射，反射，
因此为了方便后续添加新的物体，采用了继承和虚函数的方法来实现代码上的多态。
设置一个公共类shape，每个物体都继承了该类，并且需要填补虚函数
intersect(光线与该物体求交)
Reflection（反射）
getN(求该物体上某点的法向量)
insideRayTracing（物体内部的光线追踪，
由于与外部求交有所不同（比如不必对其他物体判交）所以单独写）

这样，不同的物体只需要调用同一个名字的接口就可以求对应的内容，而之后代码
更新新的物体也只需要继承原来的shape类，并且完成以上提到的四个函数，就可以
添加新的物体

2）环境光影响整体的明暗度，如果环境光稍微亮一点就会使得整个环境显得非常亮，高光区域
也会变得非常多。环境光反射系数在环境光较亮的情况下决定了物体的颜色，不过物体很有可能是偏亮色的
漫反射光则是决定物体颜色的另一种，在环境光不亮的情况下，漫反射系数则是可以决定物体的颜色，可以得到
比较好的效果
镜面反射则是决定了物体的暗部颜色，如果镜面反射系数整体是一致的，在高光区域可能还是会保持物体颜色，可是
在较暗区域则会趋向镜面反射光的颜色
透射同理。以上两个设大的话会做出透明的效果。

3）摄像机的点投影会导致在边界区域的图像扭曲拉伸，因此比较好的解决方法还是只能把摄像机拉远一点观察，让
物体尽量就集中在中间，可能要完全解决的话还是得修改摄像机的单点投影的模型，改成其他？

4）试验可以发现光线追踪还是非常耗时间的，加入球和平面的时候还能在一分钟内求解，加入长方体（由于实现的简单，每次求交都暴力枚举其中六个面来计算交点，然后根据num取对应需要的交点）之后，运算时间加大，一个长方体加入大概10分钟之内，两个长方体大概需要20分钟左右。后续需要优化长方体的运算速度，否则计算5~6个物体就非常耗时间了
